# 如何控制寄存器

本节将介绍函数`enable_gpioe_clock`控制寄存器的过程。

## 获取抽象设备

查看`let dp = pac::Peripherals::take().unwrap();`语句，`pac::Peripherals`结构如下：
```rust,ignore
pub struct Peripherals {
    #[doc = "GPIOA"]
    pub gpioa: Gpioa,
    #[doc = "GPIOB"]
    pub gpiob: Gpiob,
    #[doc = "GPIOC"]
    pub gpioc: Gpioc,
    #[doc = "GPIOD"]
    pub gpiod: Gpiod,
...
```
此结构体包含了众多芯片外设，进一步查看`taka()`,
```rust,ignore
pub fn take() -> Option<Self> {
    critical_section::with(|_| {
        if unsafe { DEVICE_PERIPHERALS } {
            return None;
        }
        Some(unsafe { Peripherals::steal() })
    })
}
```
`take()`函数返回`Option<Self>`，其中`Self`是`Peripherals`结构体。如果`DEVICE_PERIPHERALS`为`true`，则返回`None`，否则返回`Some(unsafe { Peripherals::steal() })`。可以看出，此函数运行时将屏蔽所有中断，第一次运行后会将`DEVICE_PERIPHERALS`设置为`true`，从而避免再次调用`take()`。
进一步查看`Peripherals::steal()`函数。
```rust,ignore
pub unsafe fn steal() -> Self {
    unsafe {
        DEVICE_PERIPHERALS = true;
        Peripherals {
            gpioa: Gpioa::steal(),
            gpiob: Gpiob::steal(),
            gpioc: Gpioc::steal(),
            gpiod: Gpiod::steal(),
            ...
```
进一步查看`gpioa: Gpioa::steal()`:
```rust,ignore
pub unsafe fn steal() -> Self {
    Self {
        _marker: marker::PhantomData,
    }
}
```
此时，发现`Gpioa`是一个没有意义的结构体，是不是很惊讶？。我们已经接触到了rust语言的**零成本抽象(zero abstraction)** 。

## 查看代表芯片外设的结构体

我们查看`Gpioa`这个数据类型：
```rust,ignore
/// crates/stm32f303pac/src/lib.rs
pub type Gpioa = crate::Periph<gpioa::RegisterBlock, 0x4800_0000>;

/// crates/stm32f303pac/src/generic.rs
pub struct Periph<RB, const A: usize> {
    _marker: marker::PhantomData<RB>,
}
```

我们发现`Gpioa`是一个有两个泛型参数的结构体，这个机构体拥有一个泛型变量，一个泛型常量。进一步阅读`crates/stm32f303pac/src/lib.rs`可以发现所有的外设都使用`crate::Periph`进行包装。进一步查看`gpioa::RegisterBlock`的定义：

```rust,ignore
#[repr(C)]
#[doc = "Register block"]
pub struct RegisterBlock {
    moder: Moder,
    otyper: Otyper,
    ospeedr: Ospeedr,
    pupdr: Pupdr,
    idr: Idr,
    odr: Odr,
    bsrr: Bsrr,
    lckr: Lckr,
    afrl: Afrl,
    afrh: Afrh,
    brr: Brr,
}
```

这个结构使用了`#[repr(C)]`属性，表示结构体的内存排列将使用c语言格式。

结合上述内容，我们可以知道`Periph<RB, const A: usize>`中的`RB`为芯片外设的寄存器块，`A`为外设的基地址。这个结构体使用了`#[repr(C)]`属性，表示结构体的内存排列将使用c语言格式，因此结构体的成员本身的地址将等于芯片寄存器的地址。

当我们继续查看`pub struct Periph<RB, const A: usize>`可以发现：
```rust,ignore
/// crates/stm32f303pac/src/generic.rs
impl<RB, const A: usize> Periph<RB, A> {
    #[doc = "Pointer to the register block"]
    pub const PTR: *const RB = A as *const _;
    #[doc = "Return the pointer to the register block"]
    #[inline(always)]
    pub const fn ptr() -> *const RB {
        Self::PTR
    }
...
impl<RB, const A: usize> core::ops::Deref for Periph<RB, A> {
    type Target = RB;
    #[inline(always)]
    fn deref(&self) -> &Self::Target {
        unsafe { &*Self::PTR }
    }
}
```

`Periph`具有一个`PTR`常量，这个常量表示寄存器块的指针，数值为`A`，也就是`pub type Gpioa = crate::Periph<gpioa::RegisterBlock, 0x4800_0000>;`中的`0x4800_0000`。`core::ops::Deref`实现了`Deref` trait，使得`Periph`解引用时自动转化为`RB`结构体，且结构体的基地址为`A`。

我们回到此处：
```rust,ignore
{{#include ../../pac_led/src/main.rs:10:17}}
```
`dp.rcc.ahbenr().modify(|_, w| w.iopeen().set_bit());`实际上调用了`deref()`方法，然后访问 RegisterBlock 的`ahbenr`字段。其地址为芯片寄存器对应的地址。

## 操作寄存器

获取到寄存器对应的字段后，需要对其进行读写操作。但有的寄存器是只读寄存器，有的寄存器只能写入特定的数值，这些在C/C++，这类语言中无法使用静态检查避免误操作，但rust语言可以。

我们继续查看：
```rust,ignore
{{#include ../../pac_led/src/main.rs:10:17}}
```
